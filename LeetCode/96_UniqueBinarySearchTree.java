/*定义G(n): 长度为n的序列的不同二叉搜索树个数。

F(i,n): 以i为根的不同二叉搜索树个数(1≤i≤n)

G(n)= ∑ F(i,n){i=1~n}

对于边界情况，当序列长度为 1 （只有根）或为 0 （空树）时，都只有一种情况;

F(i,n)=G(i−1)⋅G(n−i)

即G(n)= ∑G(i−1)⋅G(n−i){i=1~n}*/

class Solution {
    public int numTrees(int n) {
        int[] G = new int[n + 1];  //存储从0~n个数可以构成成的二叉搜索树
        G[0] = 1; //0的时候是空树
        G[1] = 1;
        for(int i = 2; i <= n; i++){
            for(int j = 1; j <= i; j++){ //如果给定n,那么就要计算以1~n作为根结点时的所有情况和
                G[i] += G[j - 1] * G[i - j]; //G[j-1]代表1~j-1作为左子树；j-1-1+1
                //G[i-j]代表j+1~i作为右子树;i-(j+1)+1;j作为根结点是左子树和右子树的笛卡尔积
            }
        }
        return G[n];
    }
}
